slug: "interpreter"
name: "Build your own Interpreter"
short_name: "Interpreter"
release_status: "beta"

description_md: |-
  This challenge follows the book [Crafting Interpreters](https://craftinginterpreters.com/) by Robert Nystrom.

  In this challenge you'll build an interpreter for [Lox](https://craftinginterpreters.com/the-lox-language.html), a simple scripting
  language. Along the way, you'll learn about tokenization, ASTs, tree-walk interpreters and more.

  Before starting this challenge, make sure you've read the "Welcome" part of the book that contains these chapters:

  - [Introduction](https://craftinginterpreters.com/introduction.html) (chapter 1)
  - [A Map of the Territory](https://craftinginterpreters.com/a-map-of-the-territory.html) (chapter 2)
  - [The Lox Language](https://craftinginterpreters.com/the-lox-language.html) (chapter 3)

  These chapters don't involve writing code, so they won't be covered in this challenge. This challenge will start
  from chapter 4, [Scanning](https://craftinginterpreters.com/scanning.html).

short_description_md: |-
  Learn about tokenization, ASTs, tree-walk interpreters and more.

completion_percentage: 15

languages:
  - slug: "gleam"
  - slug: "go"
  - slug: "kotlin"
  - slug: "ocaml"
  - slug: "python"
  - slug: "rust"
  - slug: "zig"

marketing:
  difficulty: hard
  sample_extension_idea_title: "Control flow"
  sample_extension_idea_description: "An interpreter that can handle control flow statements like if/else"
  testimonials:
    - author_name: "Ananthalakshmi Sankar"
      author_description: "Automation Engineer at Apple"
      author_avatar: "https://codecrafters.io/images/external/testimonials/oxta.jpeg"
      link: "https://github.com/anu294"
      text: "There are few sites I like as much that have a step by step guide. The real-time feedback is so good, it's creepy!"

    - author_name: "Patrick Burris"
      author_description: "Senior Software Developer, CenturyLink"
      author_avatar: "https://codecrafters.io/images/external/testimonials/patrick-burris.jpeg"
      link: "https://github.com/Jumballaya"
      text: |-
        I think the instant feedback right there in the git push is really cool.
        Didn't even know that was possible!

extensions:
  - slug: "parsing-expressions"
    name: "Parsing Expressions"
    description_markdown: |
      This extension covers chapters 5 & 6 of the book ([Representing Code](https://craftinginterpreters.com/representing-code.html) & [Parsing Expressions](https://craftinginterpreters.com/parsing-expressions.html)).

      In this extension, you'll add the ability to parse expressions.

  - slug: "evaluating-expressions"
    name: "Evaluating Expressions"
    description_markdown: |
      This extension covers chapters 7 of the book ([Evaluating Expressions](https://craftinginterpreters.com/evaluating-expressions.html)).

      In this extension, you'll add the ability to evaluate expressions.

stages:
  - slug: "ry8"
    name: "Scanning: Empty file"
    difficulty: very_easy
    description_md: |-
      Before starting this stage, make sure you've read the "Welcome" section of the book that contains these chapters:

      - [Introduction](https://craftinginterpreters.com/introduction.html) (chapter 1)
      - [A Map of the Territory](https://craftinginterpreters.com/a-map-of-the-territory.html) (chapter 2)
      - [The Lox Language](https://craftinginterpreters.com/the-lox-language.html) (chapter 3)

      These chapters don't involve writing code, so they won't be covered in this challenge. This challenge will start
      from chapter 4, [Scanning](https://craftinginterpreters.com/scanning.html).

      ---

      In this stage, you'll implement basic support for the `tokenize` command.

      ### The `tokenize` command

      The `tokenize` command tokenizes a Lox program and prints the tokens to stdout. We'll use this for testing
      all stages in the [Scanning](https://craftinginterpreters.com/scanning.html) chapter.

      If there's a file named `test.lox` with the following contents:

      ```
      var language = "lox";
      ```

      The `tokenize` command will return the following:

      ```
      $ ./your_program.sh tokenize test.lox
      VAR var null
      IDENTIFIER language null
      EQUAL = null
      STRING "lox" lox
      SEMICOLON ; null
      EOF  null
      ```

      This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning).

      Each line corresponds to a token in the file (Image from [Section 4.2: Lexemes & Tokens](https://craftinginterpreters.com/scanning.html#lexemes-and-tokens)):

      ![img](https://craftinginterpreters.com/image/scanning/lexemes.png)

      This is the format for each line:

      ```
      <token_type> <lexeme> <literal>
      ```

      - `<token_type>`: The type of the token.
        - Examples: `VAR`, `IDENTIFIER`, `STRING`, `EOF` etc.
      - `<lexeme>`: The actual sequence of characters that formed the token.
        - Examples: `var`, `breakfast`, `"bagels"` etc.
        - For an `EOF` token, the lexeme is an empty string.
      - `<literal>`: The literal value of the token.
        - For most tokens this is `null`.
        - For `STRING`/`NUMBER` tokens, it holds the value of the string/number.

      The `EOF` token is a special token that represents the end of the file. All calls to `tokenize` will include an `EOF` token at the end.

      ### Tests

      The tester will write an empty file to `test.lox`. It'll then run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      EOF  null
      ```

      Since the file is empty, only one token is expected in the output: `EOF`. The tester will verify that `EOF<space><space>null` is printed to stdout.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - There are two spaces between `EOF` and `null`. This is because the `<lexeme>` part is an empty string for the `EOF` token.
    marketing_md: |-
      In this stage, you'll implement basic support for the `tokenize` command which we'll use in all stages that are part of the [Scanning](https://craftinginterpreters.com/scanning.html) chapter.

  - slug: "ol4"
    name: "Scanning: Parentheses"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning parentheses.

      ### Book reference

      The code for this stage is implemented in [Section 4.5: Recognizing Lexemes](https://craftinginterpreters.com/scanning.html#recognizing-lexemes).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain parentheses.

      For example, if `test.lox` contains the following:

      ```
      (()
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      LEFT_PAREN ( null
      LEFT_PAREN ( null
      RIGHT_PAREN ) null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning parentheses.

  - slug: "oe8"
    name: "Scanning: Braces"
    difficulty: easy
    description_md: |-
      In this stage, you'll add support for scanning braces.

      ### Book reference

      The code for this stage is implemented in [Section 4.5: Recognizing Lexemes](https://craftinginterpreters.com/scanning.html#recognizing-lexemes).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain braces combined with parentheses.

      For example, if `test.lox` contains the following:

      ```{{=<~ ~>=}}
      {{}}
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      LEFT_BRACE { null
      LEFT_BRACE { null
      RIGHT_BRACE } null
      RIGHT_BRACE } null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning braces.

  - slug: "xc5"
    name: "Scanning: Other single-character tokens"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning other single-character tokens, like `,`, `.`, `-`, `+`, `;`, `*`.
      `/` is not covered here, it's covered in later stages.

      ### Book reference

      The code for this stage is implemented in [Section 4.5: Recognizing Lexemes](https://craftinginterpreters.com/scanning.html#recognizing-lexemes).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain parentheses, braces combined with all the new single-character tokens.

      For example, if `test.lox` contains the following:

      ```
      ({*.,+*})
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      LEFT_PAREN ( null
      LEFT_BRACE { null
      STAR * null
      DOT . null
      COMMA , null
      PLUS + null
      STAR * null
      RIGHT_BRACE } null
      RIGHT_PAREN ) null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning other single-character tokens.

  - slug: "ea6"
    name: "Scanning: Lexical errors"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for reporting errors when scanning invalid tokens like `$`, `#`, etc.

      ### Book reference

      The code for this stage is implemented in [Section 4.5.1: Lexical Errors](https://craftinginterpreters.com/scanning.html#lexical-errors).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain unknown tokens mixed with other previously introduced token types.

      For example, if `test.lox` contains the following:

      ```
      ,.$(#
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      [line 1] Error: Unexpected character: $
      [line 1] Error: Unexpected character: #
      COMMA , null
      DOT . null
      LEFT_PAREN ( null
      EOF  null
      ```

      The lexical errors, should be printed to the stderr stream, with the `[line N]` prefix at the beginning.
      The tester will assert that the stdout stream of your program matches the valid tokens, and the stderr stream contains the lexical errors.
      The tester will also assert that the exit code is non-zero, or more specifically 65 in case of lexical errors.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
      - You can use the stderr stream to print debug logs for your own use too, to register a line as an error, it has to contain the `[line N]` prefix. Else we will ignore it as an user log.
      - As the stdout and stderr are completely different streams, the order of errors and valid tokens don't matter.
    marketing_md: |-
      In this stage, you'll implement support for scanning lexical errors.

  - slug: "mp7"
    name: "Scanning: Assignment & equality Operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning assignment & equality operators.

      ### Book reference

      The code for this stage is implemented in [Section 4.5.2: Operators](https://craftinginterpreters.com/scanning.html#operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain equality & assignment operators mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      ={===}
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      EQUAL = null
      LEFT_BRACE { null
      EQUAL_EQUAL == null
      EQUAL = null
      RIGHT_BRACE } null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning the assignment & equality operators.

  - slug: "bu3"
    name: "Scanning: Negation & inequality operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning negation & inequality operators.

      ### Book reference

      The code for this stage is implemented in [Section 4.5.2: Operators](https://craftinginterpreters.com/scanning.html#operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain inequality & negation operators mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      !!===
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      BANG ! null
      BANG_EQUAL != null
      EQUAL_EQUAL == null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning negation & inequality operators.

  - slug: "et2"
    name: "Scanning: Relational operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning relational operators, which are: `<`, `>`, `<=`, `>=`.

      ### Book reference

      The code for this stage is implemented in [Section 4.5.2: Operators](https://craftinginterpreters.com/scanning.html#operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain relational operators mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      <<=>>=
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      LESS < null
      LESS_EQUAL <= null
      GREATER > null
      GREATER_EQUAL >= null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning relational operators.

  - slug: "ml2"
    name: "Scanning: Division operator & comments"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning the division operator & comments.
      Comments start with `//`, and the division operator is `/`.

      ### Book reference

      The code for this stage is implemented in [Section 4.6: Longer Lexemes](https://craftinginterpreters.com/scanning.html#longer-lexemes).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain `/` & `//` mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      // Comment
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      EOF  null
      ```

      Similarly, if `test.lox` contains the following:

      ```
      /
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      SLASH / null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning the division operator & comments.

  - slug: "er2"
    name: "Scanning: Whitespace"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning whitespaces.

      ### Book reference

      The code for this stage is implemented in [Section 4.6: Longer Lexemes](https://craftinginterpreters.com/scanning.html#longer-lexemes).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain whitespaces mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      (<|TAB|>
      <|SPACE|>)
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      LEFT_PAREN ( null
      RIGHT_PAREN ) null
      EOF  null
      ```

      The `test.lox` file will contain the space character, and tab character, but to take it more readable in logs, we will replace them with `|SPACE|` and `|TAB|` respectively. This will be done ONLY in the logs, the file will contain the actual characters.
      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning whitespaces.

  - slug: "tz7"
    name: "Scanning: Multi-line errors"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning lexical errors, which span multiple lines.

      ### Book reference

      The code for this stage is implemented in [Section 4.5.1: Lexical Errors](https://craftinginterpreters.com/scanning.html#lexical-errors).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain lexical errors spanning multiple lines.

      For example, if `test.lox` contains the following:

      ```
      #<|SPACE|>(
      )<|TAB|>@
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      [line 1] Error: Unexpected character: #
      [line 2] Error: Unexpected character: @
      LEFT_PAREN ( null
      RIGHT_PAREN ) null
      EOF  null
      ```

      The tester will assert that the stdout & stderr of your program matches the format above.
      Pay special attention to the line number in your error strings.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning multi-line errors.

  - slug: "ue7"
    name: "Scanning: String literals"
    difficulty: hard
    description_md: |-
      In this stage, you'll add support for scanning string literals.

      ### Book reference

      The code for this stage is implemented in [Section 4.6.1: String literals](https://craftinginterpreters.com/scanning.html#string-literals).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain string literals inside double quotes, mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      "foo baz"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      STRING "foo baz" foo baz
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      If string is unterminated, you should raise a lexical error.
      For example, if `test.lox` contains the following:

      ```
      "bar
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      [line 1] Error: Unterminated string.
      EOF  null
      ```

      The tester will assert that an error is raised, and that the error string matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning string literals.

  - slug: "kj0"
    name: "Scanning: Number literals"
    difficulty: hard
    description_md: |-
      In this stage, you'll add support for scanning number literals.

      ### Book reference

      The code for this stage is implemented in [Section 4.6.2: Number literals](https://craftinginterpreters.com/scanning.html#number-literals).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain number literals mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      1234.1234
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      NUMBER 1234.1234 1234.1234
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning number literals.

  - slug: "ey7"
    name: "Scanning: Identifiers"
    difficulty: hard
    description_md: |-
      In this stage, you'll add support for scanning identifiers.

      ### Book reference

      The code for this stage is implemented in [Section 4.7: Reserved Words and Identifiers](https://craftinginterpreters.com/scanning.html#reserved-words-and-identifiers).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain identifiers mixed with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      foo bar _hello
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      IDENTIFIER foo null
      IDENTIFIER bar null
      IDENTIFIER _hello null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning identifiers.

  - slug: "pq5"
    name: "Scanning: Reserved words"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for scanning reserved words, which are: `and`, `class`, `else`, `false`, `for`, `fun`, `if`, `nil`, `or`, `print`, `return`, `super`, `this`, `true`, `var`, `while`.

      ### Book reference

      The code for this stage is implemented in [Section 4.7: Reserved Words and Identifiers](https://craftinginterpreters.com/scanning.html#reserved-words-and-identifiers).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain reserved words mixed with other previously introduced token types.

      For example, if `test.lox` contains the following:

      ```
      and
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh tokenize test.lox
      AND and null
      EOF  null
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/tree/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/scanning)
      - When scanning for tokens, it's valid to have "unbalanced" parentheses or braces. When we get to parsing expressions in later stages, these cases will be highlighted as errors.
    marketing_md: |-
      In this stage, you'll implement support for scanning reserved words.

  - slug: "sc2"
    primary_extension_slug: "parsing-expressions"
    name: "Booleans & Nil"
    difficulty: hard
    description_md: |-
      In this stage you'll implement support for the `parse` command and handle parsing `true`, `false`, and `nil` literals.

      ### Book reference

      Before starting this stage, make sure you've read the [Representing Code](https://craftinginterpreters.com/representing-code.html) chapter (chapter 5). The
      code covered in that chapter (`AstPrinter`) will be required to generate the output tested in this stage.

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### The `parse` command

      In the previous stages, the tester used the `tokenize` command to test your scanner implementation. In this extension, the tester will need to test
      your parser implementation, so it'll use a different command instead: `parse`.

      The `parse` command accepts a path to a file (`test.lox` for example) and prints out the AST representation of the file to stdout.

      For example, if `test.lox` contains the following:

      ```
      2 + 3
      ```

      The `parse` command will return the following:

      ```
      $ ./your_program.sh parse test.lox
      (+ 2.0 3.0)
      ```

      This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox).

      For the same file, here's what the output from `tokenize` would've been:

      ```
      $ ./your_program.sh tokenize test.lox
      NUMBER 2.0 2.0
      PLUS +
      NUMBER 3.0 3.0
      EOF  null
      ```

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain the boolean values `true` & `false`, and the `nil` literal.

      For example, if `test.lox` contains the following:

      ```
      true
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      true
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
      <!-- TODO: Clarify how `nil` must be printed: `nil`/`null`? -->
    marketing_md: |-
      In this stage, you'll implement support for parsing binary values and the nil literal.

  - slug: "ra8"
    primary_extension_slug: "parsing-expressions"
    name: "Number literals"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing number literals.

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain number literals, we include both integers and floats.

      For example, if `test.lox` contains the following:

      ```
      42.47
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      42.47
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing number literals.

  - slug: "th5"
    primary_extension_slug: "parsing-expressions"
    name: "String literals"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing string literals.

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain string literals, it can contain whitespaces, and numbers too, but everything is inside double quotes.

      For example, if `test.lox` contains the following:

      ```
      "hello"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      hello
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing string literals.

  - slug: "xe6"
    primary_extension_slug: "parsing-expressions"
    name: "Parentheses"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing parentheses.

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain parentheses, combined with number literals, string literals and booleans.

      For example, if `test.lox` contains the following:

      ```
      ("foo")
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      (group foo)
      ```

      The tester will assert that the stdout of your program matches the format above.

      The tester will also check whether your program exits with code 65 if there are unmatched parentheses. For example, if `test.lox` contains the following:

      ```
      ("foo"
      ```

      The tester will run your program like this and assert that the exit code is 65:

      ```
      $ ./your_program.sh parse test.lox
      Error: Unmatched parentheses.
      ```

      The exact error message will not be checked, the tester will only check that the program exits with code 65.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing parentheses.

  - slug: "mq1"
    primary_extension_slug: "parsing-expressions"
    name: "Unary Operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing the negation operator (`-`) & the logical not operator (`!`).

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain unary operators, combined with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      !true
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      (! true)
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing unary operators `!` and `-`.

  - slug: "wa9"
    primary_extension_slug: "parsing-expressions"
    name: "Arithmetic operators (1/2)"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing the multiplication operator (`*`) & the division operator (`/`).

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain multiplicative algebraic operators, combined with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      16 * 38 / 58
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      (/ (* 16.0 38.0) 58.0)
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing multiplicative algebraic operators `*` and `/`.

  - slug: "yf2"
    primary_extension_slug: "parsing-expressions"
    name: "Arithmetic operators (2/2)"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing the addition operator (`+`) & the subtraction operator (`-`).

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain additive algebraic operators, combined with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      52 + 80 - 94
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      (- (+ 52.0 80.0) 94.0)
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing additive algebraic operators `+` and `-`.

  - slug: "uh4"
    primary_extension_slug: "parsing-expressions"
    name: "Comparison operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing comparison operators: `>`, `<`, `>=` & `<=`.

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain comparison operators, combined with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      83 < 99 < 115
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      (< (< 83.0 99.0) 115.0)
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing comparison operators `>`, `<`, `>=` & `<=`.

  - slug: "ht8"
    primary_extension_slug: "parsing-expressions"
    name: "Equality operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for parsing equality operators: `==` & `!=`.

      ### Book reference

      The code for this stage is implemented in [Section 6.2: Recursive Descent Parsing](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain comparison operators, combined with previously introduced tokens.

      For example, if `test.lox` contains the following:

      ```
      "baz" == "baz"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      (== baz baz)
      ```

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
    marketing_md: |-
      In this stage, you'll implement support for parsing equality operators `==` & `!=`.

  - slug: "wz8"
    primary_extension_slug: "parsing-expressions"
    name: "Syntactic errors"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for handling syntax errors in expressions.

      ### Book reference

      The code for this stage is implemented in [Section 6.3: Syntax Errors](https://craftinginterpreters.com/parsing-expressions.html#syntax-errors).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain syntax errors.

      For example, if `test.lox` contains the following:

      ```
      (72 +)
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh parse test.lox
      [line 1] Error at ')': Expect expression.
      ```

      The tester will assert that the exit code is 65.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/parse.lox)
      - The tester won't check the exact error message in this stage, it will only check that the program exits with code 65.
    marketing_md: |-
      In this stage, you'll implement support for handling syntax errors in expressions.

  - slug: "iz6"
    primary_extension_slug: "evaluating-expressions"
    name: "Literals: Booleans & Nil"
    difficulty: hard
    description_md: |-
      In this stage you'll implement support for the `evaluate` command and handle evaluating the `true`, `false`, and `nil` literals.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.1: Evaluating Literals](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-literals).

      ### The `evaluate` command

      In the previous stages, the tester used the `parse` command to test your parser implementation. In this extension, the tester will need to test
      your evaluator implementation, so it'll use a different command instead: `evaluate`.

      The `evaluate` command accepts a path to a file (`test.lox` for example) and prints out the result of evaluating the file to stdout.

      For example, if `test.lox` contains the following:

      ```
      2 + 3
      ```

      The `evaluate` command will return the following:

      ```
      $ ./your_program.sh evaluate test.lox
      5
      ```

      This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox).

      For the same file, here's what the output from `parse` would've been:

      ```
      $ ./your_program.sh parse test.lox
      (+ 2.0 3.0)
      ```

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain the boolean values `true` & `false`, and the `nil` literal.

      For example, if `test.lox` contains the following:

      ```
      true
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      true
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `true` | `true` |
      | `false` | `false` |
      | `nil` | `nil` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - For the `nil` literal, the tester will check that the program prints `nil`.
    marketing_md: |-
      In this stage, you'll implement support for evaluating binary values and the nil literal.

  - slug: "lv1"
    primary_extension_slug: "evaluating-expressions"
    name: "Literals: Strings & Numbers"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating number and string literals.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.1: Evaluating Literals](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-literals).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain number literals and string literals.

      For example, if `test.lox` contains the following:

      ```
      "hello world!"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      hello world!
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `"hello world!"` | `hello world!` |
      | `10.40` | `10.4` |
      | `10` | `10` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - For the string literals, the tester will check that the program prints the string without quotes.
      - For the number literals, the tester will check that the program prints the number with the minimum number of decimal places without losing precision. (For example, 10.40 should be printed as 10.4).
    marketing_md: |-
      In this stage, you'll implement support for evaluating number and string literals.

  - slug: "oq9"
    primary_extension_slug: "evaluating-expressions"
    name: "Parentheses"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating expressions inside parentheses.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.2: Evaluating parentheses](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-parentheses).

      ### Tests

      The tester will test your program using a `test.lox` file that contains an expression with parentheses.

      For example, if `test.lox` contains the following:

      ```
      ("hello world!")
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      hello world!
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `("hello world!")` | `hello world!` |
      | `(true)` | `true` |
      | `(10.40)` | `10.4` |
      | `((false))` | `false` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - String literals & number literals must be formatted using the same rules as the previous stage.
    marketing_md: |-
      In this stage, you'll implement support for evaluating expressions inside parentheses.

  - slug: "dc1"
    primary_extension_slug: "evaluating-expressions"
    name: "Unary Operators: Negation & Not"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating unary operators `-` and `!`.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.3: Evaluating unary expressions](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-unary-expressions).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with unary operators.

      For example, if `test.lox` contains the following:

      ```
      -(73)
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      -73
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `-73` | `-73` |
      | `!true` | `false` |
      | `!10.40` | `false` |
      | `!((false))` | `true` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - For truthyness and falsyness, we will follow the convention introduced in the book, where `false` and `nil` are falsy, and everything else is truthy.
    marketing_md: |-
      In this stage, you'll implement support for evaluating unary operators `-` and `!`.

  - slug: "bp3"
    primary_extension_slug: "evaluating-expressions"
    name: "Arithmetic Operators (1/2)"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating binary operators `*` and `/`.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.5: Evaluating binary operators](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-binary-operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with the arithmetic operators `*` and `/`.

      For example, if `test.lox` contains the following:

      ```
      (18 * 3 / (3 * 6))
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      3
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `42 / 5` | `8.4` |
      | `18 * 3 / (3 * 6)` | `3` |
      | `(10.40 * 2) / 2` | `10.4` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - In this stage, you can assume we will not test for error cases. Runtime errors will be introduced in later stages. For now, all arithmetic operations will involve only two numbers.
    marketing_md: |-
      In this stage, you'll implement support for evaluating binary operators `*` and `/`.

  - slug: "jy2"
    primary_extension_slug: "evaluating-expressions"
    name: "Arithmetic Operators (2/2)"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating binary operators `+` and `-`.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.5: Evaluating binary operators](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-binary-operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with the arithmetic operators `+` and `-`.

      For example, if `test.lox` contains the following:

      ```
      20 + 74 - (-(14 - 33))
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      75
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `70 - 65` | `5` |
      | `69 - 93` | `-24` |
      | `10.40 - 2` | `8.4` |
      | `23 + 28 - (-(61 - 99))` | `13` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - In this stage, you can assume we will not test for error cases. Runtime errors will be introduced in later stages. For now, all arithmetic operations will involve only two numbers.
    marketing_md: |-
      In this stage, you'll implement support for evaluating binary operators `+` and `-`.

  - slug: "jx8"
    primary_extension_slug: "evaluating-expressions"
    name: "String Concatenation"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for overloading the `+` operator. When the `+` operator is applied to two strings, it should concatenate them.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.5: Evaluating binary operators](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-binary-operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with the operator `+`.

      For example, if `test.lox` contains the following:

      ```
      "hello" + " world!"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      hello world!
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `"hello" + " world!"` | `hello world!` |
      | `"42" + "24"` | `4224` |
      | `"foo" + "bar"` | `foobar` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - In this stage, you can assume we will not test for error cases. Runtime errors will be introduced in later stages. For now, we will only pass 2 strings to the `+` operator in this stage.
    marketing_md: |-
      In this stage, you'll implement support for overloading the `+` operator. When the `+` operator is applied to two strings, it should concatenate them.

  - slug: "et4"
    primary_extension_slug: "evaluating-expressions"
    name: "Relational Operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating relational operators `>`, `<`, `>=` & `<=`.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.5: Evaluating binary operators](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-binary-operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with the relational operators `>`, `<`, `>=` & `<=`.

      For example, if `test.lox` contains the following:

      ```
      10 > 5
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      true
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `57 > -65` | `true` |
      | `11 >= 11` | `true` |
      | `(54 - 67) >= -(114 / 57 + 11)` | `true` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - In this stage, you can assume we will not test for error cases. Runtime errors will be introduced in later stages. For now, all relational operations will involve only two numbers.
    marketing_md: |-
      In this stage, you'll implement support for evaluating relational operators `>`, `<`, `>=` & `<=`.

  - slug: "hw7"
    primary_extension_slug: "evaluating-expressions"
    name: "Equality Operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for evaluating equality operators `==` and `!=`.

      ### Book reference

      The code for this stage is implemented in [Section 7.2.5: Evaluating binary operators](https://craftinginterpreters.com/evaluating-expressions.html#evaluating-binary-operators).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with the equality operators `==` and `!=`.

      For example, if `test.lox` contains the following:

      ```
      156 == (89 + 67)
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      true
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `"hello" == "world"` | `false` |
      | `"foo" != "bar"` | `true` |
      | `"foo" == "foo"` | `true` |
      | `61 == "61"` | `false` |

      The tester will assert that the stdout of your program matches the format above.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
      - In this stage, you can assume we will not test for error cases. Runtime errors will be introduced in later stages. For now, all equality operations will involve only two numbers or two strings.
    marketing_md: |-
      In this stage, you'll implement support for evaluating equality operators `==` and `!=`.

  - slug: "gj9"
    primary_extension_slug: "evaluating-expressions"
    name: "Runtime Errors: Unary Operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for handling runtime errors while evaluating the unary operator `-`.

      ### Book reference

      The code for this stage is implemented in [Section 7.3: Runtime Errors](https://craftinginterpreters.com/evaluating-expressions.html#runtime-errors).

      ### Tests

      The tester will test your program using a `test.lox` file that contains an expression with the unary operator `-`. This expression
      will contain a usage of the `-` operator that should throw a runtime error.

      The unary operator `-` will throw a runtime error if the operand is not a number.

      For example, if `test.lox` contains the following:

      ```
      -"hello world!"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      Operand must be a number.
      [line 1]
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `-"foo"` | `Operand must be a number.` |
      | `-true` | `Operand must be a number.` |
      | `-("foo" + "bar")` | `Operand must be a number.` |
      | `-false` | `Operand must be a number. `|

      The tester will assert that the exit code is 70, signifying a runtime error. Note that this is different from the expected exit code for a syntax error, which is 65.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
    marketing_md: |-
      In this stage, you'll implement support for handling runtime errors while evaluating the unary operator `-`.

  - slug: "yu6"
    primary_extension_slug: "evaluating-expressions"
    name: "Runtime Errors: Binary Operators (1/2)"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for handling runtime errors while evaluating the binary operators `*` & `/`.

      ### Book reference

      The code for this stage is implemented in [Section 7.3: Runtime Errors](https://craftinginterpreters.com/evaluating-expressions.html#runtime-errors).

      ### Tests

      The tester will test your program using a `test.lox` file that contains an expression with the binary operators `*` or `/`. This expression
      will contain a usage of the `*` or `/` operator that should throw a runtime error.

      The binary operators `*` & `/` will throw a runtime error if the operands are not both numbers.

      For example, if `test.lox` contains the following:

      ```
      "foo" / 42
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      Operands must be numbers.
      [line 1]
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `"foo" * 42` | `Operands must be numbers.` |
      | `true / 2` | `Operands must be numbers.` |
      | `("foo" * "bar")` | `Operands must be numbers.` |
      | `false / true` | `Operands must be numbers. `|

      The tester will assert that the exit code is 70, signifying a runtime error. Note that this is different from the expected exit code for a syntax error, which is 65.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
    marketing_md: |-
      In this stage, you'll implement support for handling runtime errors while evaluating the binary operators `*` & `/`.

  - slug: "cq1"
    primary_extension_slug: "evaluating-expressions"
    name: "Runtime Errors: Binary Operators (2/2)"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for handling runtime errors while evaluating the binary operators `+` & `-`.

      ### Book reference

      The code for this stage is implemented in [Section 7.3: Runtime Errors](https://craftinginterpreters.com/evaluating-expressions.html#runtime-errors).

      ### Tests

      The tester will test your program using a `test.lox` file that contains an expression with the binary operators `+` or `-`. This expression
      will contain usages of the `+` or `-` operator that should throw a runtime error.

      The binary operators `+` & `-` will throw a runtime error if the operands are not both numbers or both strings.

      For example, if `test.lox` contains the following:

      ```
      17 + "bar"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      Operands must be two numbers or two strings.
      [line 1]
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `"foo" + true` | `Operands must be numbers.` |
      | `42 - true` | `Operands must be numbers.` |
      | `true + false` | `Operands must be numbers.` |
      | `"foo" - "bar"` | `Operands must be numbers. `|

      The tester will assert that the exit code is 70, signifying a runtime error. Note that this is different from the expected exit code for a syntax error, which is 65.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
    marketing_md: |-
      In this stage, you'll implement support for handling runtime errors while evaluating the binary operators `+` & `-`.

  - slug: "ib5"
    primary_extension_slug: "evaluating-expressions"
    name: "Runtime Errors: Relational Operators"
    difficulty: medium
    description_md: |-
      In this stage, you'll add support for handling runtime errors while evaluating the relational operators `>`, `<`, `>=` & `<=`.

      ### Book reference

      The code for this stage is implemented in [Section 7.3: Runtime Errors](https://craftinginterpreters.com/evaluating-expressions.html#runtime-errors).

      ### Tests

      The tester will run a series of tests with `test.lox` files that contain expressions with the relational operators `>`, `<`, `>=` & `<=`, There is a high probability that the expression will throw a runtime error.

      The tester will test your program using a `test.lox` file that contains an expression with the relational operator `>`, `<`, `>=` or `<=`. This expression
      will contain a usage of the relational operator that should throw a runtime error.

      The relational operators `>`, `<`, `>=` & `<=` will throw a runtime error if the operands are not numbers.

      For example, if `test.lox` contains the following:

      ```
      17 > "bar"
      ```

      The tester will run your program like this:

      ```
      $ ./your_program.sh evaluate test.lox
      Operands must be numbers.
      [line 1]
      ```

      The tester will run multiple such tests with randomized expressions, for example:

      | Input | Expected output |
      | :---: | :-------------: |
      | `"foo" < false` | `Operands must be numbers.` |
      | `true < 2` | `Operands must be numbers.` |
      | `("foo" + "bar") < 42` | `Operands must be numbers.` |
      | `false > true` | `Operands must be numbers. `|

      The tester will assert that the exit code is 70, signifying a runtime error. Note that this is different from the expected exit code for a syntax error, which is 65.

      ### Notes

      - This output format matches the spec in the [book's repository](https://github.com/munificent/craftinginterpreters/blob/01e6f5b8f3e5dfa65674c2f9cf4700d73ab41cf8/test/expressions/evaluate.lox)
    marketing_md: |-
      In this stage, you'll implement support for handling runtime errors while evaluating the relational operators `>`, `<`, `>=` & `<=`.
